#!/usr/bin/env sh

### kagami v0.4 â€” static microblog processor
### (c) 2020 microsounds <https://github.com/microsounds>, GPLv3+
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 3
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Suite 500, Boston, MA  02110-1335, USA.

#
#
## ERROR CHECKING
#
mode='error'
mesg_st() { printf '%s%s' "${mode:+[$mode] }" "$@"; } # for prompts?
mesg() { mesg_st "$@"; printf '\n'; }
quit() { mesg "$@, exiting." 1>&2; exit 1; }

# requirements
markdown='cmark-gfm'
for f in dc $markdown dc; do
	command -v "$f" > /dev/null || quit "'$f' is not installed"
done
# enable cmark extensions
for f in footnotes table strikethrough autolink; do
	markdown="$markdown -e $f"
done
markdown="$markdown --smart --unsafe"

# Any dir or parent thereof that contains the following dirs will
# be considered the working directory.
# All operations are relative to this dir.
config='.kagami' # configuration directory
source='src'     # source markdown documents

# Kagami will run only if the 2 dirs described above actually exist,
# even if they're empty. Kagami tries to be fault-tolerant when convenient.
# Missing files aren't an issue, Kagami will only complain about it.
working_dir="$PWD"
while [ ! -z "$working_dir" ] && [ ! -d "$working_dir/$config" ]; do
	working_dir="${working_dir%/*}"
done
[ ! -z "$working_dir" ] ||
	quit "Directory '$config' not found in this or any parent dir up to /"

source_dir="$working_dir/$source"
[ -d "$source_dir" ] ||
	quit "Markdown documents expected in '$source_dir'"

config_dir="$working_dir/$config"
for f in head.htm tail.htm macros; do
	[ -f "$config_dir/$f" ] || ( mode='!'; mesg "Expected '$config_dir/$f'"; )
done

unset mode

#
#
## OPTION FLAGS
#
### usage: kagami [options]
###  clean       Recursively deletes all output files that would have been
###              created under normal operation.
###  -h          Displays this message.

unset clean
for f in "$1"; do case "$f" in
	-h) egrep '^#{3} ' < "$0" | sed 's/^#\{3\} //'; exit 1;;
	clean) clean=1;;
esac; done

#
#
## FILE OPERATIONS
#
# compare file mtime in a peculiar way
# if either file doesn't exist, assume first file is always newer
is_newer() (
	res="$(find "$1" -newer "$2" 2> /dev/null)" || return 0
	[ ! -z "$res" ]
)

# returns relative filename of newest file in a directory
# if dir is empty, or doesn't exist, or is actually a file, return nothing
newest_file() (
	file="$(ls -at1 "$1" | tail -n +2 | head -n 1)" 2> /dev/null
	# ls just echos your filename back to you if it's a file
	[ "$1" = "$file" ] && unset file
	echo "$file"
)

#
#
## METADATA ROUTINES
#
# derive date from a timestamp
simple_date() (
	[ ! -z "$1" ] || [ "$1" -eq "$1" ] 2> /dev/null || return 1
	date -d "1970-01-01 UTC $1 seconds" '+%B %Y'
)

# derive full date and moon phase from a timestamp
fancy_date() (
	[ ! -z "$1" ] || [ "$1" -eq "$1" ] 2> /dev/null || return 1

	# calculate days since a specific new moon
	# divide by length of lunar cycle
	# express lit portion of the moon in percent
	known=633381600 # Jan 26th, 1990 was a new moon
	lit=$(echo "2k $1 $known - 86400 / 29.53 / 100 % n" | dc)

	# express floor(abs(lit portion)) with an available glyph
	steps=7; phase='ðŸŒ• ðŸŒ– ðŸŒ— ðŸŒ˜ ðŸŒ‘ ðŸŒ’ ðŸŒ“ ðŸŒ”'
	map=$(printf '%.0f' $(echo "${lit#-} $steps * n" | dc))
	moon=$(echo "$phase" | tr ' ' '\n' | tail -n +$((map + 1)) | head -n 1)

	# current date
	timest=$(date -d "1970-01-01 UTC $1 seconds" '+%-e %a, %b x, %Y')
	day="${timest%% *}"
	case $day in
		1 | [!1]1) day="${day}st";;
		2 | [!1]2) day="${day}nd";;
		3 | [!1]3) day="${day}rd";;
		*) day="${day}th"
	esac
	echo "$moon ${timest#* }" | sed "s/x/$day/"
)

# get page title from first '<h1>' heading in markdown file
md_title() (
	title="$(grep '^# ' < "$1" | sed 's/^# //' | head -n 1)"
	echo "${title:-${1##*/}}" # filename as fallback
)

# get created/updated timestamps from first 2 inline comments in
# file that take the form '<!--word xxxx/xx/xx-->'
md_timestamp() (
	st='^<!--'; ed='-->$'
	egrep "$st" < "$1" | sed -e "s/$st//" -e "s/$ed//" | head -n 2 |
		while read -r date; do
		# return valid dates only
		date -d "${date#* }" '+%s' 2> /dev/null
	done
)

# generate a markdown index of files in the same directory sorted by
# descending creation date, files without timestamps will not show up
# on this list
# file URLs are relative to index.md for now
md_index() (
	cd "$1"
	for f in *.md; do
		secs="$(md_timestamp "$f" | head -n 1)"
		if [ ! -z "$secs" ] && date="$(simple_date "$secs")"; then
			list="$list\n$secs\t* [$(md_title "$f")]($f) --- _${date}_"
		fi
	done
	# remove trailing newline and sort by date
	echo "$list" | grep . | sort -nr | cut -f2
)

#
#
## MACROS
#
# valid macro identifiers
mformat='[A-Za-z0-9_]+'

# global environment macros
VERSION="$("$0" -h | grep '^kagami')"
DOC_ROOT="$working_dir"

# import user-provided macros
[ -f "$config_dir/macros" ] && . "$config_dir/macros"

#
#
## MAIN ROUTINES
#
# get the filename of the newest file in the config directory
config_newest="$config_dir/$(newest_file "$config_dir")"

# go through directory recursively, all paths must be absolute
process_dir() (
	mode='error' # sanity check
	case "$1" in [!/]*) quit "'$1' not an absolute path";; esac
	! cd "$1" 2> /dev/null && quit "Could not enter '$1'" ||
	for file in *; do
		# recurse subdirectory
		[ -d "$1/$file" ] && process_dir "$1/$file"

		# generate matching output file for every markdown file found
		# file path rewritten to land outside of source dir
		# subdirs are created if they don't exist
		case "$file" in *.md);; *) continue; esac
		orig="$1/$file"
		new="${orig%.*}.htm"
		new="$working_dir${new#$source_dir}"
		new_dir="${new%/*}"
		[ -d "$new_dir" ] ||
			( mode='/'; mesg "created $new_dir"; mkdir -p "$new_dir"; )

		# clean mode
		# delete output files that would have been generated under
		# normal operation if they exist
		if [ ! -z "$clean" ]; then
			[ -f "$new" ] && ( mode='-'; mesg "$new"; )
			rm -rf "$new"
			continue
		fi

		# index files have a dynamic index and are always refreshed
		unset index
		case "$orig" in *index.md) touch "$orig"; index=1;; esac

		# generate an output file if stale or non-existent
		# non-existent files are implicitly older and will be created
		# if config dir has been modified, all files are considered stale
		if is_newer "$orig" "$new" || is_newer "$config_newest" "$new"; then
			# local environment macros
			timest="$(md_timestamp "$orig")"
			TITLE="$(md_title "$orig")"
			CREATED="$(fancy_date $(echo "$timest" | tail -n +1 | head -n 1))"
			UPDATED="$(fancy_date $(echo "$timest" | tail -n +2 | head -n 1))"

			# 2-stage pipeline
			# process entire output file in memory to reduce disk write latency
			{
				# concatenate page content
				cat "$config_dir/head.htm"
				echo '<!--{VERSION}-->'
				# cmark escapes macro identifiers in inline links
				$markdown < "$orig" | sed -e 's/%7B/{/g' -e 's/%7D/}/g'
				# regenerate index for this directory
				if [ ! -z "$index" ]; then
					echo '<div class="index">'
					md_index "${orig%/*}" | $markdown
					echo '</div>'
				fi
				cat "$config_dir/tail.htm"
			} | {
		 		# macro processing
				tmp="$(cat /dev/stdin)"
				for ext in \
					$(echo "$tmp" | egrep -o "\{$mformat\}" | sort | uniq); do
					# strip braces
					int="${ext#?}"; int="${int%?}"
					# interpret inline macros as shell variables
					eval "int=\${$int}"
					# replace macro with contents of shell variable if set
					tmp="$(echo "$tmp" | sed "s\`$ext\`$int\`g")"
				done
				# convert links to other markdown files
				echo "$tmp" | sed 's,\.md,\.htm,g'
			} > "$new" && ( mode='+'; mesg "$new"; )
		fi
	done
)

process_dir "$source_dir"
