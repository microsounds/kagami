#!/usr/bin/env sh

#v# kagami v0.5.4 â€” static microblog processor
#v# (c) 2021 microsounds <https://github.com/microsounds>, GPLv3+
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 3
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Suite 500, Boston, MA  02110-1335, USA.

#
#
## OPTION FLAGS
#
#h# usage: kagami [options]
#h#  clean            Recursively deletes all output files that would have
#h#                   been created under normal operation.
#h#  -h, --help       Displays help message.
#h#  -v, --version    Displays version information.
unset clean
for f in "$1"; do case "$f" in
	-*[vh]*)
		sel=$(echo "$f" | tr -d '-' | cut -c 1)
		egrep "^#$sel" < "$0" | sed 's/[^ ]* //'
		exit 1;;
	clean) clean=1;;
esac; done

#
#
## GLOBAL / ERROR CHECKING
#
mode='error'
mesg_st() { printf '%s%s' "${mode:+[$mode] }" "$@"; } # for prompts?
mesg() { mesg_st "$@"; printf '\n'; }
quit() { mesg "$@, exiting." 1>&2; exit 1; }
require() { command -v "$1" > /dev/null; }

# launches spinning progress indicator
# sets global variable SPINNER indicating pid of current spinner
set_spinner() {
	while :; do
		for f in '\' '|' '/' '-'; do
			( mode="$f"; mesg_st "$1"; )
			printf '\r'
			sleep 0.05
		done
	done &
	SPINNER="$!"
}
clear_spinner() { kill "$SPINNER"; printf '\r'; }

# define non-colliding single-byte sed delimiter
# this character CANNOT appear in expanded macros or processed
# markdown documents under any circumstances
delim="$(printf '\01')" # non-printable 0x01

# require GNU date from GNU coreutils
date --version | fgrep -q 'GNU' || quit "GNU date is required"

# select markdown utility
# prefer cmark-gfm, fallback to standard cmark if not found.
cmark='cmark-gfm'; opts='--smart'
if require "$cmark"; then
	# enable github flavored markdown extensions
	for f in --unsafe footnotes table strikethrough autolink; do
		case $f in
			-*) opts="$opts $f";;
			*) opts="$opts -e $f"
		esac
	done
else
	cmark="${cmark%-*}"
	require "$cmark" || quit "$cmark not installed"
fi
markdown="$cmark $opts"

# any dir or parent thereof that contains the following dirs will
# be considered the working directory.
# all operations are relative to this dir.
config='.kagami' # configuration directory
source='.src'     # source markdown documents

# Kagami will run only if the 2 dirs described above actually exist,
# even if they're empty. Kagami tries to be fault-tolerant when convenient.
# Missing files aren't an issue, Kagami will only complain about it.
working_dir="$PWD"
while [ ! -z "$working_dir" ] && [ ! -d "$working_dir/$config" ]; do
	working_dir="${working_dir%/*}"
done
[ ! -z "$working_dir" ] ||
	quit "Directory '$config' not found in this or any parent dir up to /"

source_dir="$working_dir/$source"
[ -d "$source_dir" ] ||
	quit "Markdown documents expected in '$source_dir'"

config_dir="$working_dir/$config"
for f in head.htm tail.htm macros; do
	[ -f "$config_dir/$f" ] || ( mode='!'; mesg "Expected '$config_dir/$f'"; )
done

unset mode

#
#
## FILE OPERATIONS
#
# compare file mtime in a peculiar way
# if either file doesn't exist, assume first file is always newer
is_newer() (
	res="$(find "$1" -newer "$2" 2> /dev/null)" || return 0
	[ ! -z "$res" ]
)

# returns relative filename of newest file in a directory
# if dir is empty, or doesn't exist, or is actually a file, return nothing
newest_file() (
	file="$(ls -1t "$1" | head -n 1)"
	# ls echos your filename if it's a file
	[ "$1" = "$file" ] && unset file
	echo "$file"
)

#
#
## DATE ROUTINES
#
# simple month and year timestamp
simple_date() (
	[ ! -z "$1" ] || [ "$1" -eq "$1" ] 2> /dev/null || return 1
	date -d "1970-01-01 UTC $1 seconds" '+%B %Y'
)

full_date() (
	[ ! -z "$1" ] || [ "$1" -eq "$1" ] 2> /dev/null || return 1
	date -d "1970-01-01 UTC $1 seconds" '+%d %b %Y'
)

#
#
## MARKDOWN ROUTINES
#
# note: impure function
# generate a markdown index of files in the same directory sorted by
# descending creation date, files without timestamps will not show up
# on this list
# file URLs are relative to index.md for now
md_index() (
	cd "$1" || return
	for f in *.md; do
		curr="$(cat "$f")" # load file only once
		secs="$(echo "$curr" | md_timestamp | head -n 1)"
		title="$(echo "$curr" | md_title "$f")";
		if [ ! -z "$secs" ] && date="$(simple_date "$secs")"; then
			list="$list\n$secs\t* [$title]($f) --- _${date}_"
		fi
	done
	# remove trailing newline and sort by date
	printf '%s\n\n' '<div class="index">'
	echo "$list" | grep . | sort -nr | cut -f2
	printf '\n%s\n' '</div>'
)

# strip stray markdown/HTML syntax from input
md_strip() (
	sed -e 's/^# //' -e 's/<[^>]*>//g'
)

# get page title from first '<h1>' heading in markdown file
# strip stray inline html syntax
# (optional) accepts filename argument as fallback
md_title() (
	title="$(grep '^# ' < /dev/stdin | md_strip | head -n 1)"
	echo "${title:-${1##*/}}" # filename as fallback
)

# return newline delimited list of unix timestamps derived from every page
# comment containing well formed GNU date compatible date strings in the form
# '<!--word xxxx/xx/xx-->'
md_timestamp() (
	st='^<!-- *'; ed=' *-->$'
	grep "$st" < /dev/stdin | sed -e "s/$st//" -e "s/$ed//" \
		| while read -r date; do
		# return valid dates only
		date -d "${date#* }" '+%s' 2> /dev/null
	done
)

# create attribute identifier name from input
# strip markdown/HTML syntax extra hard for use in identifiers
md_toc_id() (
	md_strip | tr -cd 'A-Za-z0-9-_:. ' | tr ' ' '-'
)

# generate anchor id-linked markdown bullet list
# from from all headings in markdown document
md_toc() (
	IFS='
	'
	printf '%s\n\n' '<div class="toc">'
	echo 'Table of Contents'
	while read -r line; do
		case "$line" in
			\#*)
				# convert h1-6 markdown headings to
				# their equivalent as a space indented bullet list
				prefix="$(echo "${line% *}" | tr -cd '#')"
				prefix="$(tr '\0' ' ' < /dev/zero \
					| dd count=2 bs=$((${#prefix} - 1)) 2> /dev/null)"
				heading="${line#* }"
				printf '%s* [%s](#%s)\n' \
					"$prefix" "$(echo "$heading" | md_strip)" \
					"$(echo "$heading" | md_toc_id)";;
		esac
	done < /dev/stdin
	printf '\n%s\n' '</div>'
)

# append anchor id to every heading in markdown document
md_toc_anchor() (
	IFS='
	'
	while read -r line; do
		case "$line" in
			\#*)
				heading="${line#* }"
				printf '%s<span id="%s"></span>\n' \
					"$line" "$(echo "$heading" | md_toc_id)";;
			*) echo "$line"
		esac
	done < /dev/stdin
)

#
#
## MACROS
#
# valid macro identifiers
mformat='[A-Za-z0-9_]+'

# global environment macros
export VERSION="$("$0" --version | grep '^kagami')"
export DOC_ROOT="$working_dir"
export DATE_FUNCTION='full_date' # fallback date function

# import user-provided macros
[ -f "$config_dir/macros" ] && . "$config_dir/macros"

# report on global state
[ -z "$clean" ] && for f in DOC_ROOT; do
	eval "val=\${$f}"
	( mode="$f"; mesg "${val:-(unset)}"; )
done

#
#
## MAIN ROUTINES
#
# get the filename of the newest file in the config directory
config_newest="$config_dir/$(newest_file "$config_dir")"

# go through directory recursively, all paths must be absolute
process_dir() (
	mode='error' # sanity check
	case "$1" in [!/]*) quit "'$1' not an absolute path";; esac
	! cd "$1" 2> /dev/null && quit "Could not enter '$1'" ||
	for file in *; do
		# recurse subdirectory
		[ -d "$1/$file" ] && process_dir "$1/$file"

		# generate matching output file for every markdown file found
		# file path rewritten to land outside of source dir
		case "$file" in *.md);; *) continue; esac
		orig="$1/$file"
		new="${orig%.*}.htm"
		new="$working_dir${new#$source_dir}"

		# clean mode
		# delete output files that would have been generated under
		# normal operation if they exist
		if [ ! -z "$clean" ]; then
			[ -f "$new" ] && ( mode='-'; mesg "$new"; )
			rm -rf "$new"
			continue
		fi

		# subdirs are created if they don't exist
		new_dir="${new%/*}"
		[ -d "$new_dir" ] ||
			( mode='/'; mesg "created $new_dir"; mkdir -p "$new_dir"; )

		# index files have a dynamic index and are always refreshed
		unset index
		case "$orig" in *index.md) touch "$orig"; index=1;; esac

		# generate an output file if stale or non-existent
		# non-existent files are implicitly older and will be created
		# if config dir has been modified, all files are considered stale
		if is_newer "$orig" "$new" || is_newer "$config_newest" "$new"; then

			# load markdown document only once
			set_spinner "$new"
			tmp="$(cat "$orig")"

			# generate local environment macros
			timest="$(echo "$tmp" | md_timestamp)"
			TITLE="$(echo "$tmp" | md_title "$new")"
			CREATED="$($DATE_FUNCTION $(echo "$timest" | head -n 1))"
			UPDATED="$($DATE_FUNCTION $(echo "$timest" | tail -n +2 | head -n 1))"

			# optional macro TOC
			# generate markdown table of contents
			# append inline anchors to markdown document
			echo "$tmp" | fgrep -q '{TOC}' && {
				TOC="$(echo "$tmp" | md_toc | $markdown)"
				tmp="$(echo "$tmp" | md_toc_anchor)"
			}

			# { concat; } | { macro; } > output
			# process entire file in memory to reduce disk latency
			{
				# concatenate page content
				cat "$config_dir/head.htm"
				echo '<!--{VERSION}-->'

				# cmark aggressively escapes macro identifiers in inline links
				echo "$tmp" | $markdown | sed -e 's/%7B/{/g' -e 's/%7D/}/g'
				# regenerate index for this directory
				if [ ! -z "$index" ]; then
					md_index "${orig%/*}" | $markdown
				fi
				cat "$config_dir/tail.htm"
			} | {
				# macro expansion
				# convert inline links to other markdown files
				script='s,\.md,\.htm,g;'

				# queue macro substitutions into a single sed invocation
				tmp="$(cat /dev/stdin)"
				for ext in \
					$(echo "$tmp" | egrep -o "\{$mformat\}" | sort | uniq); do
					# strip braces
					int="${ext#?}"; int="${int%?}"
					# interpret inline macros as shell variables
					eval "int=\${$int}"
					# replace macro with contents of shell variable if set
					script="${script}s${delim}${ext}${delim}${int}${delim}g;"
				done
				# strip newlines before expansion
				echo "$tmp" | sed -e "$(echo "$script" | tr -d '\n')"
			} > "$new" && \
					clear_spinner && ( mode='+'; mesg "$new"; )
		fi
	done
)

process_dir "$source_dir"
