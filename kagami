#!/usr/bin/env sh

## kagami v0.2 â€” static microblog generator
# Copyright (c) 2020 microsounds <https://github.com/microsounds>
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 3
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Suite 500, Boston, MA  02110-1335, USA.

# environment and error checking
mode='error'
mesg_st() { printf '%s%s' "${mode:+[$mode] }" "$@"; } # for prompts
mesg() { mesg_st "$@"; printf '\n'; }
quit() { mesg "$@, exiting."; exit 1; }

# dependency checking
markdown='cmark-gfm'
which $markdown > /dev/null || quit "$markdown is not installed"
for f in footnotes table strikethrough autolink; do
	markdown="$markdown -e $f"
done

# Any dir or parent thereof that contains the following dirs becomes
# the working dir, all operations are relative to this dir.
config='.kagami' # configuration directory
source='src'     # source markdown documents

# kagami will run only if the 2 dirs described above actually exist,
# even if they're empty. kagami tries to be fault-tolerant when convenient.
# Missing files aren't an issue, kagami will only complain about it.
working_dir="$PWD"
while [ ! -z "$working_dir" ] && [ ! -d "$working_dir/$config" ]; do
	working_dir="${working_dir%/*}"
done
[ ! -z "$working_dir" ] ||
	quit "Directory '$config' not found in this or any parent dir up to /"

source_dir="$working_dir/$source"
[ -d "$source_dir" ] ||
	quit "Markdown documents expected in '$source_dir'"

config_dir="$working_dir/$config"
for f in head.htm tail.htm macros; do
	(mode='!'; [ -f "$config_dir/$f" ] || mesg "Expected '$config_dir/$f'"; )
done

unset mode # end rudimentary error checking

## usage: kagami [options]
##  -h          Displays this message.
##  clean       Recursively deletes all *.htm files in the working directory,
##              excluding the config directory '.kagami'.

for f in "${@#-}"; do case "$f" in
	h) cat "$0" | grep '^## ' | sed 's/## //'; exit 1;;
	clean)
		find "$working_dir" -type f -name "*.htm" \
			! -path "$config_dir*" | while read -r file; do
				( mode='-'; mesg "$file"; )
				rm "$file"
			done
		exit 0;;
esac; done

# macro routines -- global
# Macro placeholders look like this: '{MACRO}' and can appear anywhere in
# your markup and are parsed and replaced in-place during the final step.
# Global macros come in 2 flavors, the built-in variables, and the
# user-provided shell variables described in '.kagami/macros' which override
# built-ins.
# There are also per-file specific macros which override user-provided macros
# and are generated shortly before the parse and replace step.

# valid macro identifiers
mformat='[A-Za-z0-9_]+'

# global environment macros
DOC_ROOT="$working_dir"

# import user-provided macros
[ -f "$config_dir/macros" ] && . "$config_dir/macros"

# file mtime routines
# Missing files should not cause errors and implicitly treating missing files
# as being the oldest in comparisons recreates convenient functionality found
# in some non-POSIX shells that implement -nt and -ot switches, such as bash.

# returns file mtime expressed as unix timestamp
# non-existent files will return mtime of 0
mtime() (
	mtime="$(stat -c '%Y' "$@")" 2> /dev/null
	echo "${mtime:-0}"
)
# returns newest file in directory
# returns nothing if directory empty or non-existent
newest_file() (
	file="$(ls -1t "$@" | head -1)" 2> /dev/null
	echo "$file"
)

# check mtime of the config directory
# if it's newer than existing files, all files will be regenerated
config_mtime=$(mtime "$config_dir/$(newest_file "$config_dir")")

# main routine
# recurse through source directory and convert all markdown documents found
find "$source_dir" -type f -name '*.md' | while read -r orig; do

	# creates matching output *.htm filename for every file found
	# file path is rewritten to land immediately outside of the source dir
	# subdirs are created if they don't exist
	new="$working_dir/${orig#$source_dir/}"
	new="${new%.*}.htm"
	new_dir="${new%/*}"
	[ -d "$new_dir" ] ||
		( mode='/'; mesg "created $new_dir"; mkdir -p "$new_dir"; )

	# Refresh output file if it's older than the source file.
	# If output file doesn't exist, it will have an mtime of 0, and be created.
	# Output file will also be refreshed if it's older than the newest file in
	# the config directory.
	orig_mtime=$(mtime "$orig")
	new_mtime=$(mtime "$new")
	if [ $new_mtime -lt $orig_mtime ] || [ $new_mtime -lt $config_mtime ]; then

		# concatenate markup
		( mode='+'; mesg "$new"; )
		cat "$config_dir/head.htm" > "$new"
		$markdown < "$orig" >> "$new"
		cat "$config_dir/tail.htm" >> "$new"

		# macro routines -- file-specific
		PAGE_TITLE="$(grep '^# ' "$orig" | sed 's/^# //' | head -1)"

		# macro routines -- final search and replace
		# When a macro is found, the brackets are removed, the resulting
		# identifier is interpreted as a shell variable and it's contents
		# replace the placeholder text in-place.
		# If the variable is not set, the placeholder is simply removed.
		egrep -o "\{$mformat\}" "$new" | sort | uniq | while read -r ext_macro; do
			int_macro="$(echo "$ext_macro" | egrep -o "$mformat")"
			eval "int_macro=\${$int_macro}"
			{ rm "$new"; sed "s,$ext_macro,$int_macro," > "$new"; } < "$new"
		done
	fi
done
