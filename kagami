#!/usr/bin/env sh

### kagami v0.2 â€” static microblog processor
# Copyright (c) 2020 microsounds <https://github.com/microsounds>
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 3
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Suite 500, Boston, MA  02110-1335, USA.

## rudimentary error checking
mode='error'
mesg_st() { printf '%s%s' "${mode:+[$mode] }" "$@"; } # for prompts
mesg() { mesg_st "$@"; printf '\n'; }
quit() { mesg "$@, exiting."; exit 1; }

# dependencies
markdown='cmark-gfm'
command -v "$markdown" > /dev/null || quit "'$markdown' is not installed"
for f in footnotes table strikethrough autolink; do
	markdown="$markdown -e $f"
done

# Any dir or parent thereof that contains the following dirs will
# be considered the working directory.
# All operations are relative to this dir.
config='.kagami' # configuration directory
source='src'     # source markdown documents

# Kagami will run only if the 2 dirs described above actually exist,
# even if they're empty. Kagami tries to be fault-tolerant when convenient.
# Missing files aren't an issue, Kagami will only complain about it.
working_dir="$PWD"
while [ ! -z "$working_dir" ] && [ ! -d "$working_dir/$config" ]; do
	working_dir="${working_dir%/*}"
done
[ ! -z "$working_dir" ] ||
	quit "Directory '$config' not found in this or any parent dir up to /"

source_dir="$working_dir/$source"
[ -d "$source_dir" ] ||
	quit "Markdown documents expected in '$source_dir'"

config_dir="$working_dir/$config"
for f in head.htm tail.htm macros; do
	( mode='!'; [ -f "$config_dir/$f" ] || mesg "Expected '$config_dir/$f'"; )
done

unset mode

### usage: kagami [options]
###  -h          Displays this message.
###  clean       Recursively deletes all *.htm files in the working directory,
###              excluding the config directory '.kagami'.

## command line options
for f in "$1"; do case "$f" in
	-h) egrep '^#{3} ' < "$0" | sed 's/^#\{3\} //'; exit 1;;
	clean)
		find "$working_dir" -type f -name "*.htm" \
			! -path "$config_dir*" | while read -r file; do
				( mode='-'; mesg "$file"; )
				rm "$file"
			done
		exit 0;;
esac; done

## macros
# valid macro identifiers
mformat='[A-Za-z0-9_]+'

# global environment macros
VERSION="$("$0" -h | grep '^kagami')"
DOC_ROOT="$working_dir"

# import user-provided macros
[ -f "$config_dir/macros" ] && . "$config_dir/macros"

## file operations
# compare file mtime in a peculiar way
# if either file doesn't exist, assume first file is always newer
is_newer() (
	res="$(find "$1" -newer "$2" 2> /dev/null)" || return 0
	[ ! -z "$res" ]
)

# returns relative filename of newest file in a directory
# if dir is empty, or doesn't exist, or is actually a file, return nothing
newest_file() (
	file="$(ls -at1 "$1" | tail -n +2 | head -n 1)" 2> /dev/null
	# ls just echos your filename back to you if it's a file
	[ "$1" = "$file" ] && unset file
	echo "$file"
)

# search and replace substring within a file in-place
# file persists only in stdin while original is deleted and rewritten
sed_inplace() (
	{ rm "$2"; sed "$1" > "$2"; } < "$2"
)

## main routines
# get the filename of the newest file in the config directory
config_newest="$config_dir/$(newest_file "$config_dir")"

# go through directory recursively, all paths must be absolute
process_dir() (
	echo "$1" | grep -q '^/' || quit "'$1' not an absolute path"
	cd "$1" && for file in *; do
		# recurse subdirectory
		[ -d "$1/$file" ] && process_dir "$1/$file"

		# generate matching output file for every markdown file found
		# file path rewritten to land outside of source dir
		# subdirs are created if they don't exist
		echo "$file" | grep -q '\.md$' || continue
		orig="$1/$file"
		new="${orig%.*}.htm"
		new="$working_dir${new#$source_dir}"
		new_dir="${new%/*}"
		[ -d "$new_dir" ] ||
			( mode='/'; mesg "created $new_dir"; mkdir -p "$new_dir"; )

		# generate an output file if stale or non-existent
		# non-existent files are implicitly older and will be created
		# if config dir has been modified, all files are considered stale
		if is_newer "$orig" "$new" || is_newer "$config_newest" "$new"; then

			# concatenate page content
			( mode='+'; mesg "$new"; )
			rm -rf "$new"
			for f in head content tail; do
				if [ "$f" != 'content' ]; then
					cat "$config_dir/$f.htm" >> "$new"
				else
					# cmark escapes special chars in inline links
					$markdown < "$orig" |
						sed -e 's/%7B/{/' -e 's/%7D/}/' >> "$new"
				fi
			done

			# convert links to other markdown files
			sed_inplace "s,\.md,\.htm," "$new"

			# local environment macros
			PAGE_TITLE="$(grep '^# ' < "$orig" | sed 's/^# //' | head -n 1)"
			[ ! -z "$PAGE_TITLE" ] || PAGE_TITLE="${new##*/}" # fallback

			# interpret inline macros as shell variables
			# replace macro placeholder with contents of shell variable if set
			egrep -o "\{$mformat\}" < "$new" |
				sort | uniq | while read -r ext_macro; do
				int_macro="$(echo "$ext_macro" | egrep -o "$mformat")"
				eval "int_macro=\${$int_macro}"
				sed_inplace "s,$ext_macro,$int_macro," "$new"
			done
		fi
	done
)

process_dir "$source_dir"
